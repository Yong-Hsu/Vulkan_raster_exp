#version 450

#extension GL_EXT_debug_printf : enable
#extension GL_EXT_control_flow_attributes : enable

layout(local_size_x = 4, local_size_y = 4) in;
layout(binding = 0, rgba8) uniform writeonly image2D resultImage;

struct Camera
{
  vec3 pos;
  vec3 lookat;
  float fov;
};

layout(binding = 1) uniform UBO
{
  vec3 lightPos;
  float aspectRatio;
  vec4 fogColor;
  Camera camera;
  mat4 rotMat;
} ubo;

struct Vertex {
  vec3 pos;
  vec3 normal;
  vec2 uv;
  vec4 color;
  vec4 joint0;
  vec4 weight0;
  vec4 tangent;
};

// Define a buffer that will hold an array of Vertex structures
layout(std140, binding = 2) buffer VertexBuffer {
  Vertex vertices[];
};

float randd(vec2 co)
{
  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

float edgeFunction(const vec3 a, const vec3 b, const vec3 c) {
  return (c[0] - a[0]) * (b[1] - a[1]) - (c[1] - a[1]) * (b[0] - a[0]);
}

void main() {
  // the axis is 
  vec3 v2 = vec3(1.0, 1.0, 1.0);
  vec3 v1 = vec3(-1.0, 1.0, 1.0);
  vec3 v0 = vec3(1.0, -1.0, 1.0);
  vec3 c2 = { 1.0, 0, 0 };
  vec3 c1 = { 0, 1.0, 0 };
  vec3 c0 = { 0, 0, 1.0 };
  
  for (int x = 0; x <= 8; x++)
  {
    debugPrintfEXT("invoc %v2u, vert %v3f ", gl_GlobalInvocationID.xy, vertices[x].pos);
  }

  const int w = 256;
  const int h = 256;

  // Project triangle onto the screen
  v0[0] /= v0[2], v0[1] /= v0[2];
  v1[0] /= v1[2], v1[1] /= v1[2];
  v2[0] /= v2[2], v2[1] /= v2[2];
  // Convert from screen space to NDC then raster (in one go)
  v0[0] = (1 + v0[0]) * 0.5 * w, v0[1] = (1 + v0[1]) * 0.5 * h;
  v1[0] = (1 + v1[0]) * 0.5 * w, v1[1] = (1 + v1[1]) * 0.5 * h;
  v2[0] = (1 + v2[0]) * 0.5 * w, v2[1] = (1 + v2[1]) * 0.5 * h;

  #ifdef PERSP_CORRECT
  // Divide vertex-attribute by the vertex z-coordinate
  c0[0] /= v0[2], c0[1] /= v0[2], c0[2] /= v0[2];
  c1[0] /= v1[2], c1[1] /= v1[2], c1[2] /= v1[2];
  c2[0] /= v2[2], c2[1] /= v2[2], c2[2] /= v2[2];
  // Pre-compute 1 over z
  v0[2] = 1 / v0[2], v1[2] = 1 / v1[2], v2[2] = 1 / v2[2];
  #endif

  float area = edgeFunction(v0, v1, v2);
  
  for (uint j = 0; j < h; ++j) 
  {
    for (uint i = 0; i < w; ++i) 
    {
      // memoryBarrier();
      vec3 p = { i + 0.5, h - j + 0.5, 0 };
      float w0 = edgeFunction(v1, v2, p);
      float w1 = edgeFunction(v2, v0, p);
      float w2 = edgeFunction(v0, v1, p);
      if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
        w0 /= area, w1 /= area, w2 /= area;
        float r = w0 * c0[0] + w1 * c1[0] + w2 * c2[0];
        float g = w0 * c0[1] + w1 * c1[1] + w2 * c2[1];
        float b = w0 * c0[2] + w1 * c1[2] + w2 * c2[2];
        #ifdef PERSP_CORRECT
        float z = 1 / (w0 * v0[2] + w1 * v1[2] + w2 * v2[2]);
        // Multiply the result by z for perspective-correct interpolation
        r *= z, g *= z, b *= z;
        #endif
        vec3 color = vec3(r * 255, g * 255, b * 255);
        // debugPrintfEXT("write %u %u, color %v3f", j, i, color);
        imageStore(resultImage, ivec2(j, i), vec4(color, 1.0));
      }
    }
  }
}
